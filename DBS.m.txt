classdef DBS < audioPlugin
    properties
        % initialize state structure
%         state = struct();
        state = struct('fs',44100,'d',0.25,'c',344,'previousinputs',zeros(ceil((0.25/344)* 44100),2),'max_delay',ceil((0.25/344)* 44100),'param',[0,0]);
%          
        % initialize output
        output = [];
        Angle = 0;
        param =[];
        gain = 0;

    end
    properties (Constant)
        PluginInterface = audioPluginInterface( ...           % <== (3) Map tunable property to plugin parameter.
            audioPluginParameter('Angle', ...
                'Mapping',{'lin',-90,90}));
    end
    properties (Access = private)
        % insert your private parameters here. These parameters are not
        % visible for the user.
        % No changes needed
         counter = 0; %% increment this counter in your proc_buf to read in the successive blocks
        % to get the right gain at a given instance  
    end
    methods
        % processing algorithm
        function proc_buf = process(plugin, input,param)
            % calculate output from input, state, and param
            % to have access to saved additional parameters (e.g. var) in 
            % state type in var = plugin.state.x;
            N = size(input,2);%we pass number of channels as first param? 
            A = 1/N;
            plugin.param(2)=N;
            
            %input has 
           
            plugin.param(1) = plugin.state.param;
%             plugin.param(1)=Angle;

            delay = (plugin.state.d/plugin.state.c)* sin(deg2rad(plugin.param(1)));
            
            if plugin.param(2)<0
                delay = -delay;
            end 

            sample_delay= ceil(delay *plugin.state.fs);

            if plugin.param(1)>0
                left_buf = [plugin.state.previousinputs(end-sample_delay+1:end,1);input(1:end-sample_delay,1)]*A   ;
                right_buf = input(:,2)*A   ;
                proc_buf = left_buf + right_buf;
%                 proc_buf = [left_buf , right_buf];
                %apply delay to mic 1
            else 
                right_buf = [plugin.state.previousinputs(end-sample_delay+1:end,2);input(1:end-sample_delay,2)]*A   ;
                left_buf = input(:,1)*A   ;
                proc_buf = left_buf + right_buf;
%                 proc_buf = [left_buf , right_buf];                %apply delay to mic 2
            end 
            [proc_buf,plugin.state.OAcoef_out] = GSLC_process_2ChansDelayed(proc_buf,plugin.state.OAcoef_out,plugin.param(1),sample_delay,plugin.state.micDist,plugin.state.fs,plugin.state.c);
            % update state
            % e.g. plugin.state.x = plugin.state.x + 1;
            plugin.output = [proc_buf,proc_buf];
            proc_buf = [proc_buf,proc_buf];
            plugin.state.previousinputs= input;
            % write output to outbuf to be available outside the function
%             plugin.output = proc_buf;
            plugin.counter = plugin.counter+1; %%% here is the increment
            
                        
        end
        % initialization routine
        function initialize(plugin,initdata)
            % generate a default state and return it
              x = 0;
              plugin.state.BufferSize = initdata.initdata.pagesize;
              plugin.state.fs = initdata.fs;
              plugin.state.c = initdata.initdata.c;
              plugin.state.micDist = initdata.initdata.micDist;
              plugin.state.OAcoef_out = zeros(plugin.state.BufferSize,1);  
              plugin.state.previousinputs = zeros(ceil((plugin.state.micDist /plugin.state.c)* plugin.state.fs),2);
              plugin.state.param = initdata.initdata.Angle;
              plugin.state.max_delay = ceil((plugin.state.micDist /plugin.state.c)* plugin.state.fs);

        end
        % get number of input channels
        function output = getnuminchan(plugin)
            % return number of input channels
            % No changes needed
            output = -1; % arbitrary number of input channels
        end
        % get number of output channels
        function output = getnumoutchan(plugin,input)
            % return number of input channels
            % No changes needed
            % input here number of channels
            output = -1; % arbitrary number of input channels
        end        
        % get parameter names
        function output = getparamnames(plugin)
            % return a cell array with parameter names
            % Provides labels for the slider bars controlling each parameter -
            % One slider bar for each parameter
            % Should have same number of elements as 'getparamranges''gain','Steering Angle '
            output = {};
        end
        % get parameter range
        function output = getparamranges(plugin)
            % return a cell array with parameter ranges
            % Set the min and max values of the slider bar of each parameter
            % Should have same number of elements as 'getparamnames'[-5,5],[-90,90]
            output = {}; %%% adjust the range of the output
        end
    end
end